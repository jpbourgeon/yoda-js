(self.webpackChunkgh_pages=self.webpackChunkgh_pages||[]).push([[760],{1879:function(e,t,a){"use strict";var n=a(6393),i=a(315),r=a.n(i);r().initialize({startOnLoad:!0});t.Z=function(e){var t=e.chart;return(0,n.useEffect)((function(){r().contentLoaded()}),[]),n.createElement("div",{className:"mermaid"},t)}},7974:function(e,t,a){"use strict";a.r(t),a.d(t,{frontMatter:function(){return l},contentTitle:function(){return d},metadata:function(){return c},toc:function(){return p},default:function(){return u}});var n=a(9926),i=a(845),r=(a(6393),a(158)),o=a(1879),s=["components"],l={},d="Data modeling",c={unversionedId:"data_modeling",id:"data_modeling",isDocsHomePage:!1,title:"Data modeling",description:"Document-oriented databases are built on the assumption that modeling and storing your data as documents is a better fit for common applications. At the storage level however, the design of your data will greatly impact the way your application performs in matter of replication, querying and storage efficiency.",source:"@site/docs/200_data_modeling.md",sourceDirName:".",slug:"/data_modeling",permalink:"/docs/data_modeling",tags:[],version:"current",sidebarPosition:200,frontMatter:{},sidebar:"docsSidebar",previous:{title:"Architecture",permalink:"/docs/architecture"},next:{title:"Replication",permalink:"/docs/replication"}},p=[{value:"Channels",id:"channels",children:[]},{value:"Documents events",id:"documents-events",children:[]},{value:"Materialized views",id:"materialized-views",children:[]},{value:"Secondary indexes",id:"secondary-indexes",children:[{value:"Automatic dates",id:"automatic-dates",children:[]}]},{value:"Attachments",id:"attachments",children:[]},{value:"Universally unique Lexicographically sortable IDentifiers (ULID)",id:"universally-unique-lexicographically-sortable-identifiers-ulid",children:[]},{value:"Javascript serialization and storage efficiency",id:"javascript-serialization-and-storage-efficiency",children:[]},{value:"Reserved words",id:"reserved-words",children:[]}],m={toc:p};function u(e){var t=e.components,a=(0,i.Z)(e,s);return(0,r.kt)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"data-modeling"},"Data modeling"),(0,r.kt)("p",null,"Document-oriented databases are built on the assumption that ",(0,r.kt)("a",{parentName:"p",href:"https://docs.couchdb.org/en/latest/intro/why.html#a-different-way-to-model-your-data"},"modeling and storing your data as documents")," is a better fit for common applications. At the storage level however, the design of your data will greatly impact the way your application performs in matter of replication, querying and storage efficiency."),(0,r.kt)("p",null,"This article explains the choices made upon data structure in Yoda, to answer these challenges."),(0,r.kt)("p",null,"To make it clear, there are two types of documents in a Yoda instance : items and their attachments."),(0,r.kt)("p",null,"The following chart summarizes Yoda's storage architecture. When you insert a document locally into Yoda, it is converted into an event which is inserted into a time series and aggregated into a graph. Additionally for attachments, the files binary data are saved in an appropriate storage. Conversely, when Yoda receives an event from the network, it will be stored in the corresponding graph and time series, and will then transformed into a valid document to be queried later."),(0,r.kt)(o.Z,{chart:'flowchart TB\n\tRE[Replication] <--\x3e ST\n\tsubgraph ST["Channel(s)"]\n\t\tdirection TB\n\t\tIG[(Items graph)] -.- IE[(Items events)] -.- IV[(Materialized<br>views)]\n\t\tAG[(Attachments<br>graph)] -.- AE[(Attachments<br>events)] -.- AV[("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;files&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;")]\n\tend\n\tST <--\x3e EQ[Editing / querying]\n  %%\n  classDef layer fill: #ffffde, stroke: #aaaa33, stroke-width: 1px;\n  classDef title position: relative, top: -0.35em;\n  class RE,EQ layer;\n  class ST title;\n',mdxType:"Mermaid"}),(0,r.kt)("p",null,"The structure of a Yoda item is the following. and will be further discussed in the article:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'interface Item<T> {\n    _meta: {\n        _channel: string,\n        _id: string,\n        _rev: string,\n        _createdAt?: Date,\n        _updatedAt?: Date,\n        _deleted?: boolean,\n        _deletedAt?: Date,\n        _purged?: boolean,\n        _purgedAt?: Date\n    },\n    _data: T,\n    _attachments: { _id: "", _filename: "", _contentType: "", _length: "" }[] | undefined,\n}\n')),(0,r.kt)("h2",{id:"channels"},"Channels"),(0,r.kt)("p",null,"A channel in Yoda is an abstract representation that brings together:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"A logical storage unit"),". It is a cohesive group of resources used to store a set of related documents together with their corresponding events graphs. Depending on the execution context, these resources could be a combination of any type of compatible storage : one or more databases, a folder on the filesystem, an S3 bucket..."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"A security layer"),". The authentication strategy is evaluated at the channel level: a user is explicitly granted read only or full access to a channel."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"A bi-directional communication channel"),". Replication operations always run against a specific channel. A replication message or request is published to or received from a specific channel.")),(0,r.kt)("p",null,"A Yoda instance can host any number of channels."),(0,r.kt)("p",null,"The special ",(0,r.kt)("inlineCode",{parentName:"p"},"_local")," channel is used for local only data. Its content will never be synchronized outside the instance."),(0,r.kt)("h2",{id:"documents-events"},"Documents events"),(0,r.kt)("p",null,"Yoda adopts the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/azure/architecture/patterns/event-sourcing"},"immutable history / event sourcing")," pattern to store documents."),(0,r.kt)("p",null,"When you publish a document to a Yoda instance, a unique ",(0,r.kt)("inlineCode",{parentName:"p"},"_id")," identifier is generated for the document. Additionally for items updates, Yoda compares the provided item with its previous version (if any) and only retains the difference in the event's content. A unique ",(0,r.kt)("inlineCode",{parentName:"p"},"_rev")," identifier is generated for this new revision of the item."),(0,r.kt)("p",null,"The system stores this document as an event in the ",(0,r.kt)("inlineCode",{parentName:"p"},"_primary")," index, under the appropriate ",(0,r.kt)("inlineCode",{parentName:"p"},"_itm_events")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"_att_events")," partition for items or attachments respectively, with a compound sort key made of ",(0,r.kt)("inlineCode",{parentName:"p"},"_rev")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"_id")," for items and ",(0,r.kt)("inlineCode",{parentName:"p"},"_id")," as a sort key for attachments."),(0,r.kt)("p",null,"Additionally the appropriate graph is updated, ",(0,r.kt)("inlineCode",{parentName:"p"},"_itm_graph")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"_att_graph")," for items or attachments respectively, to handle attachments synchronization across devices."),(0,r.kt)("h2",{id:"materialized-views"},"Materialized views"),(0,r.kt)("p",null,"Yoda stores the submitted documents with storage and replication efficiency in mind. However, the event sourcing storage pattern is not the best format for reading efficiency and can have a negative effect on queries."),(0,r.kt)("p",null,"To support efficient querying Yoda maintains local views of the items. Querying and data extraction are executed against these ",(0,r.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/azure/data-explorer/kusto/management/materialized-views/materialized-view-overview"},"materialized views")," or there eventual indexes."),(0,r.kt)("p",null,"The items revisions are materialized under the ",(0,r.kt)("inlineCode",{parentName:"p"},"_items")," partition key, with a compound sort key made of ",(0,r.kt)("inlineCode",{parentName:"p"},"_id")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"_rev"),"."),(0,r.kt)("p",null,"These representations of items are always computed locally. In case of inconsistency they can be discarded and rebuild from the events sources."),(0,r.kt)("h2",{id:"secondary-indexes"},"Secondary indexes"),(0,r.kt)("p",null,"Secondary indexes, compound indexes (partition keys (hash) and sort keys (range)), indexes overloading are key features in NoSQL data modeling."),(0,r.kt)("p",null,"In more advanced NoSQL databases that handle indexes (indexeddb, dynamodb, ...), the indexing capabilities of the underlying database will be used."),(0,r.kt)("p",null,"In key-value databases (like leveldb), there is no other index than the storage key. In such contexts Yoda emulates indexes by composing storage keys : the index name is prefixed to the partition key. If no index name is provided, the ",(0,r.kt)("inlineCode",{parentName:"p"},"_primary")," index will be used by default. The partition key and sort key are composed into a storage key by using a forward slash ",(0,r.kt)("inlineCode",{parentName:"p"},"/")," character."),(0,r.kt)("p",null,"Partition keys and sort keys can be usefully decomposed further. By convention, we recommend to use the hash ",(0,r.kt)("inlineCode",{parentName:"p"},"#")," character and encourage you to reserve this character to this specific usage in your keys. You are free to use any other character though (except the forward slash ",(0,r.kt)("inlineCode",{parentName:"p"},"/")," as stated above)."),(0,r.kt)("p",null,"Indexes key schemas (index name, partition key property name and sort key property name) are declared during the instance initialization. When the materialized views are calculated, the indexes are updated according to the properties names:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"if a matching partition key / sort key pair is found, the index entry will be created or updated for this item"),(0,r.kt)("li",{parentName:"ul"},"otherwise the item will be skipped on that particular index (also called a sparse index)")),(0,r.kt)("h3",{id:"automatic-dates"},"Automatic dates"),(0,r.kt)("p",null,"Since time is a key component of a document identifer, Yoda also adds useful date properties automatically in the ",(0,r.kt)("inlineCode",{parentName:"p"},"_meta")," properties of your materialized views:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_createdAt"),": creation date of the document"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_updatedAt"),": optional, last update of the document or undefined"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_deletedAt"),": optional, document deletion date or undefined"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_purgedAt"),": optional, document purge date or undefined")),(0,r.kt)("h2",{id:"attachments"},"Attachments"),(0,r.kt)("p",null,"It is generally admitted that storing files binaries in databases is a bad practice. Yoda uses a dedicated adapter to store an item's attachments binary data in a more appropriate storage (for example, the filesystem on the server, an S3 bucket on AWS, or a separate indexeddb in the browser to ensure a broader browser compatibility)."),(0,r.kt)("p",null,"Anyway, an attachment cannot exist independently of an item. It is always attached to a specific item's revision in the database, and can only be retrieved and manipulated through the item it is attached to."),(0,r.kt)("p",null,"When you attach a file to an item :"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"the file's binary data is stored in the attachment storage through the dedicated adapter. The attachment storage adapter takes care of choosing the best format for storing the attachment (blob, buffer, ...)."),(0,r.kt)("li",{parentName:"ul"},"the file's metadata is referenced into the corresponding item in its ",(0,r.kt)("inlineCode",{parentName:"li"},"_attachments")," array. These meta properties are ",(0,r.kt)("inlineCode",{parentName:"li"},"_id"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"_filename"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"_contentType")," (MIME type) and ",(0,r.kt)("inlineCode",{parentName:"li"},"_length")," (bytes)."),(0,r.kt)("li",{parentName:"ul"},"an event is generated and sorted under its ",(0,r.kt)("inlineCode",{parentName:"li"},"_id")," into the attachments series ",(0,r.kt)("inlineCode",{parentName:"li"},"_att_events")," (attachments are binary data and are not diffed or versioned, so they don't take an ",(0,r.kt)("inlineCode",{parentName:"li"},"_rev"),"property)."),(0,r.kt)("li",{parentName:"ul"},"The attachments graph ",(0,r.kt)("inlineCode",{parentName:"li"},"_att_graph")," is updated to handle attachments synchronization across devices.")),(0,r.kt)("h2",{id:"universally-unique-lexicographically-sortable-identifiers-ulid"},"Universally unique Lexicographically sortable IDentifiers (ULID)"),(0,r.kt)("p",null,"In Yoda, identifiers in general, and the ",(0,r.kt)("inlineCode",{parentName:"p"},"_id"),"and ",(0,r.kt)("inlineCode",{parentName:"p"},"_rev")," properties in particular, are critical. Thus they are fully managed by the system."),(0,r.kt)("p",null,"To ensure consistency across distributed endpoints, Yoda relies on Universally Unique Lexicographically sortable IDentifiers (",(0,r.kt)("a",{parentName:"p",href:"https://github.com/ulid/spec"},"ULID"),"). This feature guarantees that documents, and items revisions, are conflict free, even among distributed endpoints. In Yoda, the latest known ULID always wins."),(0,r.kt)("p",null,"In order to protect the system from intentional or unintentional ULID stream corruption, Yoda enforces the following policy.",(0,r.kt)("br",{parentName:"p"}),"\n","Locally, trying to post a revision to an item in the past (with a revision ULID prior to the current revision ULID) will throw an error. In the same way, editing with a revision ULID in the future (greater than the current time on the local instance) will throw an error.",(0,r.kt)("br",{parentName:"p"}),"\n","During the replication process, trying to replicate changes in the past (with a revision ULID lower than the current item ULID) or in the future (greater than the current time on the instance) will throw an error.",(0,r.kt)("br",{parentName:"p"}),"\n","If you receive such errors on a client, it most probably indicates that its internal clock is not on time. If a client's clock is late, it will experience a delay before receiving the latest changes, and its own messages will have a greater risk of being ignored in favour of more recent revisions from other instances. If a client's clock is early, it will experience a delay before being able to submit its changes."),(0,r.kt)("p",null,"To mitigate clock de-synchronization, Yoda implements a ",(0,r.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/implement-retries-exponential-backoff"},"retry strategy with exponential back-off")," in case of synchronization errors. This gives a chance to the client to catch the time window and to synchronize successfully with a delay."),(0,r.kt)("h2",{id:"javascript-serialization-and-storage-efficiency"},"Javascript serialization and storage efficiency"),(0,r.kt)("p",null,"Yoda do not store documents as JSON. You may yourself find that sometimes you need to store JavaScript dates, sets or maps... For that reason Yoda stores compressed stringified javascript objects. With Yoda, you can publish any fully qualified javascript object as a document. Yoda handles for you the object diffing, serialization and compression into events."),(0,r.kt)("p",null,"Compressed strings has been favored over alternative binary formats because they have proven to be the most ",(0,r.kt)("a",{parentName:"p",href:"https://www.lucidchart.com/techblog/2019/12/06/json-compression-alternative-binary-formats-and-compression-methods/"},"efficient way to store data")," in Javascript environments."),(0,r.kt)("h2",{id:"reserved-words"},"Reserved words"),(0,r.kt)("p",null,"As a general rule:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"your properties and values should not start with an underscore ",(0,r.kt)("inlineCode",{parentName:"li"},"_")," as this character is used to indicate reserved words in Yoda. Reserved words may be introduced as needed by plugins or future releases."),(0,r.kt)("li",{parentName:"ul"},"Your indexing values can not contain forward slashes ",(0,r.kt)("inlineCode",{parentName:"li"},"/")," as this character is used to distinguish partition key values from sort key values in key-value databases."),(0,r.kt)("li",{parentName:"ul"},"By convention, we recommend to use the ",(0,r.kt)("inlineCode",{parentName:"li"},"#")," character and encourage you to reserve this character to further decompose your partition and sort keys. You are free to use any other character though (except the forward slash ",(0,r.kt)("inlineCode",{parentName:"li"},"/"),"as stated above).")),(0,r.kt)("p",null,"Yoda reserves special words:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"channels:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_local")," (local documents channel ; they will never be replicated)"))),(0,r.kt)("li",{parentName:"ul"},"index names:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_primary")," (primary index in key-value databases)"))),(0,r.kt)("li",{parentName:"ul"},"primary index partition key values:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_itm_events")," (events)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_att_events")," (events)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_itm_graph")," (events graph)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_att_graph")," (attachments graph)"))),(0,r.kt)("li",{parentName:"ul"},"items property names:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_meta")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_data")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_attachments")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_channel")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_id")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_rev")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_createdAt")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_updatedAt")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_deleted")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_deletedAt")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_purged")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_purgedAt")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_filename")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_contentType")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_length"))))))}u.isMDXComponent=!0},2493:function(e,t,a){var n={"./locale":6090,"./locale.js":6090};function i(e){var t=r(e);return a(t)}function r(e){if(!a.o(n,e)){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}return n[e]}i.keys=function(){return Object.keys(n)},i.resolve=r,e.exports=i,i.id=2493}}]);